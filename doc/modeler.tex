\documentclass[10pt]{article}

\usepackage[table]{xcolor}
\usepackage{mathrsfs} % for mathscr
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage{hyperref} 
\usepackage{multirow}
%\usepackage{scrextend}
\usepackage{xspace}
\usepackage{booktabs}
%\usepackage{enumitem} 
\usepackage{caption} 
\usepackage{subcaption} 
\usepackage{comment}
\usepackage{longtable}
%\usepackage{subfigure}

% tuning toc, chapters, list items
\hypersetup{colorlinks,linkcolor={red!50!black},citecolor={blue!50!black},urlcolor={blue!80!black}}
\usepackage[toc,page]{appendix}
\usepackage[top=1.5in, bottom=1.5in, left=1.41in, right=1.41in]{geometry}
%\usepackage{titlesec}
%\newcommand{\chapnumfont}{\usefont{T1}{pnc}{b}{n}\fontsize{100}{100}\selectfont}
%\colorlet{chapnumcol}{gray!75}  % color for chapter number
%\titleformat{\chapter}[display]{\filleft\bfseries}{\filleft\chapnumfont\textcolor{chapnumcol}{\thechapter}}{-24pt}{\Huge}
%\setlist{topsep=2.2pt,itemsep=0.5pt} %nolistsep}%\setlist[itemize]{itemsep=0.5pt}

\usepackage{tikz}
\usetikzlibrary{shapes,calc,positioning,automata,arrows,trees}
\usepackage[tikz]{bclogo}
\renewcommand\logowidth{15pt}
\newcommand\bcpenr{\includegraphics[width=\logowidth]{crayonRed.png}} 
\newcommand\bcpen{\includegraphics[width=\logowidth]{figures/crayonBlue.png}} 
\newcommand\bcdico{\includegraphics[width=\logowidth]{figures/bookJaune.png}} 
\newcommand\bcroue{\includegraphics[width=\logowidth]{figures/roue.png}} 
%\renewcommand\bcStyleTitre[1]{\large\textbf{#1}}
%\usepackage[skins,breakable,xparse]{tcolorbox}

\newcounter{cntM3}
\newcounter{cntSy}
\newcounter{cntSe}
\newcounter{cntEx}

\usepackage{listingsutf8}



\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{remarks}{Remarks}

\definecolor{v2lgray}{gray}{0.85}
\definecolor{vlgray}{gray}{0.92}
\definecolor{mygray}{rgb}{0.92,0.98,0.92}
\definecolor{bgray}{rgb}{0.8,0.8,0.8}
\definecolor{dgray}{rgb}{0.4,0.4,0.4}
\definecolor{dblue}{RGB}{0,0,99}
\definecolor{dred}{RGB}{150,6,54}
\definecolor{dgreen}{RGB}{47,135,7}
\definecolor{d2green}{RGB}{47,85,7}
\definecolor{dviolet}{RGB}{102,0,153}
\definecolor{mblue}{RGB}{0,0,180}
\definecolor{m2blue}{RGB}{0,0,220}
\definecolor{colorse}{RGB}{255,248,220}
\definecolor{colorsy}{HTML}{F2F2F2}
\definecolor{colorex}{HTML}{FFE3BE}


\def\N{\mathbb{N}}
\def\Q{\mathbb{Q}}
\def\D{{\mathsf{D}}}
\def\B{{\mathsf{B}}}
\def\DINT{{\mathsf{D}_\mathsf{int}}}
\def\BINT{{\mathsf B}_\mathsf{int}} 
\def\ti{\textrm{-}}
\def\tr{\;\!\triangleright}
\def\st{\!:\!}

\def\gecode{Gecode\xspace}
\def\choco{Choco3\xspace}
\def\abscon{AbsCon\xspace}
\def\mzinc{MiniZinc\xspace}
\def\jacop{JaCoP\xspace}
\def\minion{Minion\xspace}
\def\xt{{\rm XCSP3}\xspace}
\def\cat{Global Constraint Catalog\xspace}

\newcommand{\xml}[1]{{\tt <#1>}} % xml element names
\newcommand{\att}[1]{{\tt #1}} % attribute names
\newcommand{\val}[1]{{\tt "#1"}} % attribute values

\newcommand{\bnf}[1]{\textsl{\color{dblue}{#1}}}
\newcommand{\bnfX}[1]{\texttt{<}\bnf{#1}\texttt{.../>}}
\newcommand{\norX}[1]{\texttt{<#1.../>}}

%\newcommand{\gb}[1]{\textcolor{dgreen}{{\tt #1}}} % global constraint names
\newcommand{\gb}[1]{{\tt #1}} % global constraint names
\newcommand{\gbc}[1]{\textcolor{dblue}{{\mathit #1}}} % global constraint names
\newcommand{\nn}[1]{{\tt #1}} % name normal
\newcommand{\nm}[1]{\mathit{#1}} % name math
\newcommand{\sy}[1]{{\ttfamily {\slshape #1}}}  % syntax elements like intValue etc.
\newcommand{\ns}[1]{{\mathcal #1}}  % symbol for set variables
\newcommand{\nss}[1]{{\mathbfcal #1}}  % symbol for set variables

\newcommand*{\com}[1]{\hfill \textcolor{dgray}{// #1}} % comment in lstlisting
\newcommand{\violet}[1]{{\small \textcolor{dviolet}{#1}}}

\newcommand{\va}[1]{{\boldsymbol #1}} % value of variable (for semantics)
%\newcommand{\va}[1]{\underline{#1}} % value of variable (for semantics)
%\newcommand{\va}[1]{#1} % value of variable (for semantics)

%\newcommand{\todoguys}[1]{\fbox{{\textcolor{red}{{\bf TODO : #1}}}}}

%\usepackage{titlesec}
%\setcounter{secnumdepth}{4}
%\setcounter{tocdepth}{3} 

\def\mt{{\rm MCSP3}\xspace}
\def\xt{{\rm XCSP3}\xspace}


\lstset{
language=Java,
basicstyle=\small, %normalsize, % ou Ã§a==> basicstyle=\scriptsize,
upquote=true,
aboveskip={1.5\baselineskip},
columns=fullflexible,
showstringspaces=false,
extendedchars=true,
escapechar=@,
breaklines=true,
showtabs=false,
showspaces=false,
showstringspaces=false,
identifierstyle=\ttfamily,
keywordstyle=\color[rgb]{0,0,1},
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\color[rgb]{0.627,0.126,0.941},
}


\newenvironment{mc}
{\medskip\bigskip\hrule\vspace{-0.35cm}} %\stepcounter{cntEx} \core{\bcroue} ,colback=colorex,title style={color=colorex}]} %,title=~ Code \thecntEx]}
{\hrule\bigskip\medskip} %end{tcolorbox}} %{\vspace{-0.1cm}\end{tcolorbox} ~ \vspace{-0.2cm}}


\def\bef{\rule{10cm}{0.1mm}\medskip}
\def\aft{\rule{10cm}{0.1mm}\medskip}

\title{\textcolor{dred}{\mt \\ Easy Modeling for Everybody}\\ \textcolor{dred}{{\large Version 0.1}}}
\author{Christophe Lecoutre \\
CRIL CNRS, UMR 8188\\ University of Artois, France \\
%\\ Rue de l'universit\'e, SP 16\\ 62307 Lens, France \\
lecoutre@cril.fr
}

\date{February 25, 2017\\~ \\\href{www.xcsp.org}{www.xcsp.org}}



\begin{document}
\maketitle


\section{Single Problems}

\subsection{A Simple Riddle}

Remember that when you were young, you were used to play at riddles, some of them having a mathematical background as for example:
\begin{quote}
Which sequence of successive four integer numbers sum up to 14?
\end{quote}

\begin{center}
  \includegraphics[scale=0.3]{figures/carambar.jpg}
\end{center}

If you were already familiar with Mathematics, maybe you were able to formalize this ridlle by:
\begin{itemize}
\item introducing four integer variables:
\begin{itemize}
  \item $x_1 \in \N$, $x_2 \in \N$, $x_3 \in \N$, $x_4 \in \N$
\end{itemize}
\item introducing the following mathematical relations (constraints):
\begin{itemize}
\item $x_1+1 = x_2$
\item $x_2+1 = x_3$
\item  $x_3+1=x_4$
\item $x_1 + x_2 + x_3 + x_4 = 14$
\end{itemize}
\end{itemize}

This is a CSP (Constraint Satisfaction problem) instance, involving four integer variables, three binary constraints and one quaternary constraint.

After a rough analysis, we can decide to set 0 as lower bound and 14 as upper bound for the possible values of the integer variables.
We then obtain the following model in \mt:

\begin{lstlisting}
@\bef@
class Riddle implements ProblemAPI {

  void model() {
    Var x1 = var("x1", dom(range(15)));
    Var x2 = var("x2", dom(range(15)));
    Var x3 = var("x3", dom(range(15)));
    Var x4 = var("x4", dom(range(15)));
    
    equal(add(x1, 1), x2);
    equal(add(x2, 1), x3);
    equal(add(x3, 1), x4);
    equal(add(x1, x2, x3, x4), 14);
  }
}
@\aft@
\end{lstlisting}

As you can observe, you just need to build a Java class that implements the interface \nn{ProblemAPI} and that contains a method \nn{model()}.
Within this method, to declare a stand-alone variable, you have to call one of the following methods \nn{var()}: 

\begin{quote}
\begin{verbatim}
Var var(String id, XDomInteger dom, String note)
Var var(String id, XDomInteger dom) 

VarSymbolic var(String id, XDomSymbolic dom, String note)
VarSymbolic var(String id, XDomSymbolic dom) 
\end{verbatim}
\end{quote}

As you can easily imagine, \nn{Var} and \nn{VarSymbolic} are the classes in the API used to represent respectively integer and symbolic variables\footnote{Support for real, set and graph variables will be proposed in a future version.}.
The specified id is the identification of the variable; it is mandatory and must be unique.
The optional parameter \nn{note} is a short comment that can be useful to describe the role of the variable.
For example, if we want ``x1 is the first variable of the sequence'' as comment in the \xt file that can be generated from this \mt model, we have to replace the first statement in Method \nn{model()} above with:

\begin{quote}
\begin{verbatim}
Var x1 = var("x1", dom(range(15)),"x1 is the first variable of the sequence");
\end{verbatim}
\end{quote}

Now, the question is: how can we build domains (objects from classes \nn{XDomInteger} and \nn{XDomSymbolic})?
The answer is that you just have to call one of the following methods \nn{dom()}: 
\begin{quote}
\begin{verbatim}
XDomInteger dom(int value1, int... otherValues) 
XDomInteger dom(int[] values) 
XDomInteger dom(Collection<Integer> values) 
XDomInteger dom(int[][] m) 
XDomInteger dom(Range range) 

XDomSymbolic dom(String value1, String... otherValues) 
XDomSymbolic dom(String[] values)
\end{verbatim}
\end{quote}

where the fifth method requires an object Range that can be obtained with one of the following methods \nn{range()}: 
\begin{quote}
\begin{verbatim}
Range range(int minIncluded, int maxIncluded, int step) 
Range range(int minIncluded, int maxIncluded) 
Range range(int length) 
\end{verbatim}
\end{quote}

  
As an illustration, the following table shows which domains are obtained for various calls.
It is important to note that integer domains are systematically sorted (without any two occurences of the same value).

\medskip\begin{tabular}{ll}
  \toprule
Call & Domain \\
  \midrule
  \verb!dom(0,1)! & $\{0,1\}$  \\
\verb!dom(1,2,5,10)! & $\{1,2,5,10\}$  \\
\verb!dom(1,2,5,10,2,4)! & $\{1,2,4,5,10\}$  \\
\verb!dom(new int[] {2,3,4})! & $\{2,3,4\}$  \\
\verb!dom(new int[][] {{1,3},{2,2},{4,6}})! & $\{1,2,3,4,6\}$  \\
\verb!dom(range(5))! & $\{0,1,2,3,4\}$  \\
\verb!dom(range(10,15))! & $\{10,11,12,13,14,15\}$  \\
\verb!dom(range(1,10,3))! & $\{1,4,7,10\}$  \\
\verb!dom("red","green","blue")! & $\{$``red'',''green'',''blue''$\}$  \\
\bottomrule
\end{tabular}
\bigskip

%\end{table}

Now, let us consider the constraints.
Here, we only use intensional constraints.
To build a constraint \gb{intension}, you have to call the method \nn{intension()} with an object \nn{XNodeParent} as parameter for representing the tree-shaped Boolean expression.
As shown below, all classical operators can be used:

\begin{quote}
\begin{verbatim}
CtrEntity intension(XNodeParent<IVar> tree) 

XNodeParent<IVar> neg(Object operand) 
XNodeParent<IVar> abs(Object operand) 
XNodeParent<IVar> add(Object... operands) 
XNodeParent<IVar> sub(Object operand1, Object operand2) 
XNodeParent<IVar> mul(Object... operands) 
XNodeParent<IVar> div(Object operand1, Object operand2) 
XNodeParent<IVar> mod(Object operand1, Object operand2) 
XNodeParent<IVar> sqr(Object operand) {
XNodeParent<IVar> pow(Object operand1, Object operand2) 
XNodeParent<IVar> min(Object... operands) 
XNodeParent<IVar> max(Object... operands) 
XNodeParent<IVar> dist(Object operand1, Object operand2) 

XNodeParent<IVar> lt(Object operand1, Object operand2) 
XNodeParent<IVar> le(Object operand1, Object operand2) 
XNodeParent<IVar> ge(Object operand1, Object operand2) 
XNodeParent<IVar> gt(Object operand1, Object operand2) 
XNodeParent<IVar> ne(Object... operands) 
XNodeParent<IVar> eq(Object... operands) 

XNode<IVar> set(Object... operands) 
XNode<IVar> set(int[] operands) 
XNodeParent<IVar> in(Object var, Object set) 

XNodeParent<IVar> not(Object operand) 
XNodeParent<IVar> and(Object... operands) 
XNodeParent<IVar> or(Object... operands) 
XNodeParent<IVar> xor(Object... operands) 
XNodeParent<IVar> iff(Object... operands) 
XNodeParent<IVar> imp(Object operand1, Object operand2) 

XNodeParent<IVar> ifThenElse(Object operand1, Object operand2, Object operand3) 
\end{verbatim}
\end{quote}

The precise semantics of these operators is given by Table \ref{tab:semanticsi}.


\begin{table}[p]
\begin{center}
{\footnotesize
\begin{tabular}{cccc} 
%\toprule
\rowcolor{v2lgray}{} {\textcolor{dred}{\bf Operation}} &  {\textcolor{dred}{\bf Arity}} &  {\textcolor{dred}{\bf Syntax}} &  {\textcolor{dred}{\bf Semantics}} \\
%\toprule
\multicolumn{2}{c}{ } \\
\multicolumn{4}{l}{\textcolor{dred}{Arithmetic (integer operands and integer result)}} \\
\midrule
%\rowcolor{vlgray}{} 
Opposite  & 1 & neg($x$) & $-x$ \\
Absolute Value &  1 & abs($x$) & $| x |$ \\
%\rowcolor{vlgray}{} 
Addition    & $r \geq 2$ & add($x_1,\ldots,x_r$) & $x_1 + \ldots + x_r$ \\
Subtraction & 2 & sub($x,y$) & $x - y$ \\
%\rowcolor{vlgray}{} 
Multiplication & $r \geq 2$ & mul($x_1,\ldots,x_r$) & $x_1 * \ldots * x_r$ \\
Integer Division & 2 & div($x,y$) & $x / y$ \\
%\rowcolor{vlgray}{} 
Remainder  & 2 & mod($x,y$) & $x \% y$ \\ 
Square  & 1 & sqr($x$) & $x^2$ \\
%\rowcolor{vlgray}{} 
Power  & 2 & pow($x,y$) & $x^{y}$ \\
Minimum & $r \geq 2$ & min($x_1,\ldots,x_r$) & $\min \{x_1,\ldots,x_r\}$ \\
%\rowcolor{vlgray}{} 
Maximum & $r \geq 2$ & max($x_1,\ldots,x_r$) & $\max \{x_1,\ldots,x_r\}$ \\
Distance  & 2 & dist($x,y$) & $| x - y |$ \\
\midrule
\multicolumn{2}{c}{ } \\
\multicolumn{4}{l}{\textcolor{dred}{Relational (integer operands and Boolean result)}} \\
\midrule
%\rowcolor{vlgray}{} 
%\rowcolor{vlgray}{} 
%\rowcolor{vlgray}{} 
Less than     & 2 & lt(x,y) & $x < y$ \\
Less than or equal     & 2 & le($x,y$) & $x \leq y$ \\
Greater than or equal     & 2 & ge($x,y$) & $x \geq y$ \\
Greater than     & 2 & gt($x,y$) & $x > y$ \\
Different from    & 2 &  ne($x,y$) & $x \neq y$ \\
Equal to    & $r \geq 2$ & eq($x_1,\ldots,x_r$) & $x_1 = \ldots = x_r$ \\
%\rowcolor{vlgray}{} 
%Disjunctive  & 4 & disj($x,y,d_x,d_y$) & $x + d_x \leq y \lor y+ d_y \leq x$ \\
\midrule
\multicolumn{2}{c}{ } \\
\multicolumn{4}{l}{\textcolor{dred}{Set ($a_i$: integers, $s$: set of integers (no variable permitted), $x$: integer operand)}} \\
\midrule
Empty set & 0 & set() & $\emptyset$ \\
Non-empty set & $r > 0$ & set$(a_1,\ldots,a_r)$ & $\{a_1,\ldots,a_r\}$ \\
Membership & 2 & in($x,s$) & $x \in s$ \\
%No Membership & 2 & notin($x,s$) & $x \notin s$ \\
\midrule
\multicolumn{2}{c}{ } \\
\multicolumn{4}{l}{\textcolor{dred}{Logic (Boolean operands and Boolean result)}} \\
\midrule
%\rowcolor{vlgray}{} 
Logical not     & 1 & not($x$) & $\lnot x$ \\
Logical and    & $r \geq 2$ &  and($x_1,\ldots,x_r$) & $x_1 \land \ldots \land x_r$ \\
%\rowcolor{vlgray}{} 
Logical or    & $r \geq 2$ & or($x_1,\ldots,x_r$) & $x_1 \lor \ldots \lor x_r$ \\
Logical xor    & $r \geq 2$ & xor($x_1,\ldots,x_r$) & $x_1 \oplus \ldots \oplus x_r$ \\
%\rowcolor{vlgray}{} 
Logical equivalence& $r \geq 2$ & iff($x_1,\ldots,x_r$) & $x_1 \Leftrightarrow \ldots \Leftrightarrow x_r$ \\
Logical implication & 2 & imp($x,y$) & $x \Rightarrow y$ \\
\midrule
\multicolumn{2}{c}{ } \\
\multicolumn{4}{l}{\textcolor{dred}{Control}} \\
\midrule
Alternative     & 3 & if($b,x,y$) & value of $x$, if $b$ is true, \\
                &   &           & value of $y$, otherwise     \\
\bottomrule
\end{tabular}
}
\end{center}
\caption{Operators on integers that can be used to build predicates. Boolean values $\nm{false}$ and $\nm{true}$ are represented by integer values $0$ and $1$.% Operators {\it eq}, {\it ne}, {\it set}, {\it in} and {\it if} can be applied on symbolic operands.
\label{tab:semanticsi}}
\end{table}

At this point, one may wonder if the constraints of our model should have been declared as:

\begin{quote}
\begin{verbatim}
intension(eq(add(x1, 1), x2));
intension(eq(add(x2, 1), x3));
intension(eq(add(x3, 1), x4));
intension(eq(add(x1, x2, x3, x4), 14));
\end{verbatim}
\end{quote}

This is correct, indeed.
However, there are some methods in the API that allow us to simplify the expression of some intensional constraints.
This is shown by the following table.

\medskip\begin{tabular}{ll}
  \toprule
Normal Form & Simplified Form \\
  \midrule
  \verb!intension(lt(...))! & \verb!lessThan(...)!  \\
  \verb!intension(le(...))! & \verb!lessEqual(...)!  \\
  \verb!intension(ge(...))! & \verb!greaterEqual(...)!  \\
  \verb!intension(gt(...))! & \verb!greaterThan(...)!  \\
  \verb!intension(eq(...))! & \verb!equal(...)!  \\
  \verb!intension(ne(...))! & \verb!notEqual(...)!  \\
  \verb!intension(imp(...))! & \verb!imply(...)!  \\
 \verb!intension(in(...))! & \verb!belong(...)!  \\
\bottomrule
\end{tabular}
\bigskip

Once you have an \mt model, you can compile it in order to get an \xt file that can be given to a constraint solver.
The command is as follows\footnote{You may need to prefix the name of the class with the relevant package information. For example, if Riddle is in packege problems.puzz, you have to write package.puzz.Riddle}:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Riddle
\end{verbatim}
\end{quote}



The content of the \xt file is: 

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <var id="x1"> 0..14 </var>
    <var id="x2"> 0..14 </var>
    <var id="x3"> 0..14 </var>
    <var id="x4"> 0..14 </var>
  </variables>
  <constraints>
    <intension> eq(add(x1,1),x2) </intension>
    <intension> eq(add(x2,1),x3) </intension>
    <intension> eq(add(x3,1),x4) </intension>
    <intension> eq(add(x1,x2,x3,x4),14) </intension>
  </constraints>
  </instance>
@\aft@
\end{lstlisting}

The variables of our problem have been declared independently, but it is possible to declare them in a one-dimensional array.
This gives:

\begin{lstlisting}
@\bef@
class Riddle2 implements ProblemAPI {

  void model() {
    Var x[] = array("x", size(4), dom(range(15)));
    
    equal(add(x[0], 1), x[1]);
    equal(add(x[1], 1), x[2]);
    equal(add(x[2], 1), x[3]);
    equal(add(x[0], x[1], x[2], x[3]), 14);
  }
}
@\aft@
\end{lstlisting}

and the \xt file obtained after compilation is:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[4]"> 0..14 </array>
  </variables>
  <constraints>
    <intension> eq(add(x[0],1),x[1]) </intension>
    <intension> eq(add(x[1],1),x[2]) </intension>
    <intension> eq(add(x[2],1),x[3]) </intension>
    <intension> eq(add(x[0],x[1],x[2],x[3]),14) </intension>
  </constraints>
</instance>
@\aft@
\end{lstlisting}

Here, we declare a one-dimensional array of variables: its id is ``x'', its size (length) is 4 and each of its variables has $\{0,1,\dots,14\}$ as domain.
Note that indexing starts at 0.
The methods for declaring one-dimensional arrays of integer or symbolic variables are:

\begin{quote}
\begin{verbatim}
Var[] array(String id, Size1D size, IntToDomInteger f, String note) 
Var[] array(String id, Size1D size, IntToDomInteger f) 
Var[] array(String id, Size1D size, XDomInteger dom, String note) 
Var[] array(String id, Size1D size, XDomInteger dom) 

VarSymbolic[] arraySymbolic(String id, Size1D size, IntToDomSymbolic f, String note) 
VarSymbolic[] arraySymbolic(String id, Size1D size, IntToDomSymbolic f) 
VarSymbolic[] arraySymbolic(String id, Size1D size, XDomSymbolic dom, String note) 
VarSymbolic[] arraySymbolic(String id, Size1D size, XDomSymbolic dom) 
\end{verbatim}
\end{quote}

where all methods require an object \nn{Size1D} that can be simply obtained by calling the following method:
\begin{quote}
\begin{verbatim}
Size1D size(int length)
\end{verbatim}
\end{quote}

Some of these methods accept lambda functions in order to let the user the possibility of declaring in the same array variables with different domains.
For example, suppose that we have analytically deduced that the two first variables of the array must be assigned a value strictly less than 6 and the two last variables of the array must be assigned a value strictly less than 9.
We can write:

\begin{lstlisting}
@\bef@
class Riddle3 implements ProblemAPI {

  void model() {
    Var x[] = array("x", size(4), i -> dom(range(i < 2 ? 6 : 9)));
    
    equal(add(x[0], 1), x[1]);
    equal(add(x[1], 1), x[2]);
    equal(add(x[2], 1), x[3]);
    equal(add(x[0], x[1], x[2], x[3]), 14);
  }
}
@\aft@
\end{lstlisting}

and the \xt file obtained after compilation is:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[4]">
      <domain for="x[0] x[1]"> 0..5 </domain>
      <domain for="x[2] x[3]"> 0..8 </domain>
    </array>
  </variables>
  <constraints>
    <intension> eq(add(x[0],1),x[1]) </intension>
    <intension> eq(add(x[1],1),x[2]) </intension>
    <intension> eq(add(x[2],1),x[3]) </intension>
    <intension> eq(add(x[0],x[1],x[2],x[3]),14) </intension>
  </constraints>
</instance>
@\aft@
\end{lstlisting}

Because the three binary constraints are similar, one may wonder if we couldn't post these constraints in a group (loop).
This is indeed possible by using the following method:

\begin{quote}
\begin{verbatim}
CtrArray forall(Range range, IntConsumer c) 
\end{verbatim}
\end{quote}


The behaviour is as follows: the specified consumer object is called for each value in the specified range, and most of the time the goal is to post a constraint when it is called.
Let us see this in action:

\begin{lstlisting}
@\bef@
class Riddle4 implements ProblemAPI {

  void model() {
    Var x[] = array("x", size(4), dom(range(15)));
    
    forall(range(3), i -> equal(add(x[i], 1), x[i + 1]));

    equal(add(x[0], x[1], x[2], x[3]), 14);
  }
}
@\aft@
\end{lstlisting}

and the \xt file obtained after compilation is:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[4]"> 0..14 </array>
  </variables>
  <constraints>
    <group>
      <intension> eq(add(%0,%1),%2) </intension>
      <args> x[0] 1 x[1] </args>
      <args> x[1] 1 x[2] </args>
      <args> x[2] 1 x[3] </args>
    </group>
    <intension> eq(add(x[0],x[1],x[2],x[3]),14) </intension>
  </constraints>
</instance>
@\aft@
\end{lstlisting}


\begin{lstlisting}
@\bef@
class Riddle5 implements ProblemAPI {

  void model() {
    Var x[] = array("x", size(4), dom(range(15)));
    
    forall(range(3), i -> equal(add(x[i], 1), x[i + 1]));
    sum(x, EQ, 14);
  }
}
@\aft@
\end{lstlisting}

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[4]"> 0..14 </array>
  </variables>
  <constraints>
    <group>
      <intension> eq(add(%0,%1),%2) </intension>
      <args> x[0] 1 x[1] </args>
      <args> x[1] 1 x[2] </args>
      <args> x[2] 1 x[3] </args>
    </group>
    <sum>
      <list> x[] </list>
      <condition> (eq,14) </condition>
    </sum>
  </constraints>
</instance>
@\aft@
\end{lstlisting}



\subsection{Playing with Small Constraint Networks}

When studying properties of constraint networks, it is frequent to draw some small constraint networks under the form of compatibility graphs (also called microstructure).
For example, Figure \ref{fig:small} presents the compatibility graph of a small constraint network $P$ such that:
\begin{itemize}
\item the set of variables of $P$ is $vars(P)=\{x,y,z\}$, each variable having $\{a,b\}$ as domain;
  \item the set of constraints of $P$ is $ctrs(P)= \{\langle x,y \rangle \in \{(a,a),(b,b)\}, \langle x,z \rangle \in \{(a,a),(b,b)\},\langle y,z \rangle \in \{(a,b),(b,a)\}$.
\end{itemize}

\begin{figure}
\begin{center}
  \includegraphics[scale=1]{figures/ACvsPIC.pdf}
\end{center}
\caption{The compatibility graph of a small constraint network.\label{fig:small}}
\end{figure}

The interested reader can observe that the constraint network is arc-consistent (AC) but not path-inverse consistent (PIC).
Anyway, the \mt model is as follows:


\begin{lstlisting}
@\bef@
public class Toy implements ProblemAPI {
  
  void model() {
    VarSymbolic x = var("x", dom("a", "b"));
    VarSymbolic y = var("y", dom("a", "b"));
    VarSymbolic z = var("z", dom("a", "b"));
    
    extension(vars(x, y), table("(a,a)(b,b)"));
    extension(vars(x, z), table("(a,a)(b,b)"));
    extension(vars(y, z), table("(a,b)(b,a)"));
  }
}
@\aft@
\end{lstlisting}

and the \xt file obtained after compilation is:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <var id="x" type="symbolic"> a b </var>
    <var id="y" type="symbolic"> a b </var>
    <var id="z" type="symbolic"> a b </var>
  </variables>
  <constraints>
    <extension>
      <list> x y </list>
      <supports> (a,a)(b,b) </supports>
    </extension>
    <extension>
      <list> x z </list>
      <supports> (a,a)(b,b) </supports>
    </extension>
    <extension>
      <list> y z </list>
      <supports> (a,b)(b,a) </supports>
    </extension>
  </constraints>
</instance>
@\aft@
\end{lstlisting}



Here, we declare three stand-alone symbolic variables (note how the domain of each of them is simply composed of the two symbols "a" and "b").
And we declare three binary constraints \gb{extension}. First, note that the scope of the constraints is specified using the method \nn{vars()}.
The many overloading versions of \nn{vars()} permit to build 1-dimensional arrays of variables from a sequence of parameters, where each element of the sequence must only contain variables (and possibly null values), either stand-alone or present in arrays (of any dimension).
All variables are collected in order, and concatenated to form a 1-dimensional array (note that null values are simply discarded).

Below, you can find all the methods that can be used to post extensional constraints.

\begin{quote}
\begin{verbatim}
CtrAlone extension(Var[] scp, int[][] tuples, boolean positive) 
CtrAlone extension(Var[] scp, int[]... tuples) 
CtrAlone extension(Var[] scp, Table table, boolean positive) 
CtrAlone extension(Var[] scp, Table table) 
CtrAlone extension(Var x, int[] values, boolean positive) 
CtrAlone extension(Var x, int... values) 

CtrAlone extension(VarSymbolic[] scp, String[][] tuples, boolean positive) 
CtrAlone extension(VarSymbolic[] scp, String[]... tuples) 
CtrAlone extension(VarSymbolic[] scp, Table table, boolean positive) 
CtrAlone extension(VarSymbolic[] scp, Table table) 
CtrAlone extension(VarSymbolic x, String[] values, boolean positive) 
CtrAlone extension(VarSymbolic x, String... values) 
\end{verbatim}
\end{quote}


When the parameter \nn{positive} is present, it indicates if the constraint lists the allowed tuples (value $true$) of the forbidden tuples (value $false$).
Note that it is possible to post unary constraints and non-unary constraints.
Specifying tuples is made possible under the form of arrays or \nn{Table} objects.
Below, here are the methods for building \nn{Table} objects:

\begin{quote}
\begin{verbatim}
Table table() 
Table table(String tuples)

TableInteger table(int[] tuple) 
TableInteger table(int val1, int... otherVals) 
TableInteger table(int[] tuple1, int[]... otherTuples) 

TableSymbolic table(String[] tuple) 
TableSymbolic table(String val1, String... otherVals) 
TableSymbolic table(String[] tuple1, String[]... otherTuples) 
\end{verbatim}
\end{quote}

Instead of:
\begin{quote}
  \verb!extension(vars(x, y), table("(a,a)(b,b)"));!
\end{quote}
we could have equivalently written:
\begin{quote}
  \verb!extension(vars(x, y), new String[][] {{"a", "a"},{"b", "b"}});!
\end{quote}

Note that there are several methods in classes \nn{Table}, \nn{TableInteger} and \nn{TableSymbolic} to build tables in a few steps.

If instead of declaring symbolic variables, you prefer to declare integer variables, replacing "a" by 0 and "b" by 1, you have to write:


\begin{lstlisting}
@\bef@
public class Toy implements ProblemAPI {
  
  void model() {
    Var x = var("x", dom(0, 1));
    Var y = var("y", dom(0, 1));
    Var z = var("z", dom(0, 1));
    
    extension(vars(x, y), table("(0,0)(1,1)"));
    extension(vars(x, z), table("(0,0)(1,1)"));
    extension(vars(y, z), table("(0,1)(1,0)"));
  }
}
@\aft@
\end{lstlisting}


Again, instead of:
\begin{quote}
  \verb!extension(vars(x, y), table("(0,0)(1,1)"));!
\end{quote}
we could have equivalently written:
\begin{quote}
  \verb!extension(vars(x, y), new int[][] {{0, 0},{1, 1}});!
\end{quote}


\section{Academic Problems}

Contrary to single problems, academic problems 


\subsection{Queens}

The problem is stated as follows: can we put 8 queens on a chessboard such that no two queens attack each other?
Two queens attack each other iff they belong to the same row, the same column or the same diagonal.
An illustration is given by Figure \ref{fig:queens}.

\begin{figure}[h]
  \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[scale=1]{figures/queen1.pdf}
        \caption{Puzzle}
    \end{subfigure}%
    ~ 
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[scale=1]{figures/queen2.pdf}
        \caption{Solution}
    \end{subfigure}
    \caption{Putting 8 queens on a chessboard \label{fig:queens}}
\end{figure}

By considering boards of various size, the problem can be generalized as follows: can we put $n$ queens on a board of size $n \times n$ such that no two queens attack each other?
Contrary to previously introduced single problems, we have to deal here with a family of problem instances, each of them characterized by a distinct value of $n$.
We can try to solve the 8-queens instance, the 10-queens instance, and even the 1000-queens instance.

For such problems, we have to separate the description of the model from the description of the data.
In other words, we have to write a model with some kind of parameters.
In \mt, this is quite natural and easy to do:
\begin{enumerate}
\item clearly identify the parameters of the problem (with their types)
\item introduce fields representing them in the class implementing \nn{ProblemAPI}
\item specify values for these parameters (fields) when you compile to \xt   
\end{enumerate}

In our case, we have only one integer parameter called $n$.
If we associate a variable $q_i$ with the ith row of the board, then we can simply post the following constraints:
\begin{quote}
  $q_i \neq q_j \land |q_i - q_j| \neq |i - j|, \forall i, j : 1 \leq i < j \leq n$
\end{quote}
This is translated as:

\begin{lstlisting}
@\bef@
class Queens implements ProblemAPI {
  int n; // number of queens

  void model() {
    Var[] q = array("q", size(n), dom(range(n)));
    
    forall(range(n).range(n), (i, j) -> {
      if (i < j)
        intension(and(ne(q[i], q[j]), ne(dist(i, j), dist(q[i], q[j]))));
    });
  }
}
@\aft@
\end{lstlisting}

Note how the parameter $n$ is used in Method \nn{model()}.
To post the constraints \gb{intension}, we use the following method:

\begin{quote}
\begin{verbatim}
CtrArray forall(Rangesx2 rangesx2, Intx2Consumer c2) 
\end{verbatim}
\end{quote}

An object \nn{Rangesx2} represents the Cartesian product of two basic ranges. In our case, it is obtained by:
\begin{quote}
\begin{verbatim}
range(n).range(n)
\end{verbatim}
\end{quote}

So, when we write:
\begin{quote}
\begin{verbatim}
forall(range(n).range(n), (i, j) -> ...
\end{verbatim}
\end{quote}
it means: $\forall (i,j) \in 0..n-1 \times 0..n-1$, $\dots$

\bigskip
Now, the question is: how can we solve a specific instance?
The answer is: just compile the model while indicating with the argument \verb!-data=! either the value for $n$ or the name of a JSON file containing an object with a unique field $n$.
In the former case, this gives for $n=4$: 
\begin{quote}
\begin{verbatim}
java modeler.Compiler Queens -data=4
\end{verbatim}
\end{quote}

and the \xt file obtained after compilation is:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="q" size="[4]"> 0..3 </array>
  </variables>
  <constraints>
    <group>
      <intension> and(ne(%0,%1),ne(%2,dist(%0,%1))) </intension>
      <args> q[0] q[1] 1 </args>
      <args> q[0] q[2] 2 </args>
      <args> q[0] q[3] 3 </args>
      <args> q[1] q[2] 1 </args>
      <args> q[1] q[3] 2 </args>
      <args> q[2] q[3] 1 </args>
    </group>
  </constraints>
</instance>
@\aft@
\end{lstlisting}

In the latter case, just build a file ``queens-4.json'' whose content is:
\begin{quote}
\begin{verbatim}
{
  "n": 4
}
\end{verbatim}
\end{quote}
and execute:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Queens -data=queens-4.json
\end{verbatim}
\end{quote}


At this point, you have been told that it could be a good idea to post a constraint \gb{allDifferent}.
So, you would like to test a slightly different model, and you think that it is annoying of multiplying files.
Actually, you can put different models in the same file by using the method \nn{isModel} that accepts a string as parameter.
When you compile, you have then to indicate the name of the model.
Putting two slightly different models in the same file gives:

\begin{lstlisting}
@\bef@
class Queens implements ProblemAPI {
  int n; // number of queens
  
  void model() {
    Var[] q = array("q", size(n), dom(range(n)));

    if (isModel("m1")) {
      forall(range(n).range(n), (i, j) -> {
	if (i < j)
  	  intension(and(ne(q[i], q[j]), ne(dist(i,  j), dist(q[i], q[j]))));
      });
    }
    if (isModel("m2")) {
      allDifferent(q);
      forall(range(n).range(n), (i, j) -> {
	if (i < j)
	  notEqual(dist(i, j), dist(q[i], q[j]));
      });
    }
  }
}
@\aft@
\end{lstlisting}

To compile the first model ("m1"), just type:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Queens -data=8 -model=m1
\end{verbatim}
\end{quote}


To compile the second model ("m2"), just type:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Queens -data=8 -model=m2
\end{verbatim}
\end{quote}




\subsection{Board Coloration Problem}

The (chess)board coloration problem is to color all squares of a board composed of $r$ rows and $c$ colomns such that the four corners of any rectangle in the board must not be assigned the same color.
Importantly, we want to minimize the number of used colors.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.1]{figures/chessboardColoration.jpg}
\end{center}
\caption{Coloring Boards.\label{fig:board}}
\end{figure}

This time, we need two integer parameters $r$ and $c$.
After a very rough analysis, we can decide to use $r \times c$ as an upper bound of the number of used colors. 
This gives:


\begin{lstlisting}
@\bef@
class BoardColoration implements ProblemAPI {
  int r; // number of rows 
  int c; // number of columns

  void model() {
    Var[][] x = array("x", size(r, c), dom(range(r * c)));
    
    forall(range(r).range(r).range(c).range(c), (i1, i2, j1, j2) -> {
      if (i1 < i2 && j1 < j2)
        notAllEqual(x[i1][j1], x[i1][j2], x[i2][j1], x[i2][j2]);
    });
    
    minimize(MAXIMUM, x);
  }
}
@\aft@
\end{lstlisting}

Here, we declare a two-dimensional array of variables: its id is ``x'', its size is $r \times c$ and each of its variables has $\{0,1,\dots,r\times c-1\}$ as domain.
Note that indexing starts at 0.
The methods for declaring two-dimensional arrays of integer variables are:

\begin{quote}
\begin{verbatim}
Var[][] array(String id, Size2D size, Intx2ToDomInteger f, String note) 
Var[][] array(String id, Size2D size, Intx2ToDomInteger f) 
Var[][] array(String id, Size2D size, XDomInteger dom, String note) 
Var[][] array(String id, Size2D size, XDomInteger dom) 
\end{verbatim}
\end{quote}

where all methods require an object \nn{Size2D} that can be simply obtained by calling the following method:
\begin{quote}
\begin{verbatim}
Size2D size(int length1, int length2)
\end{verbatim}
\end{quote}

To post the constraints \gb{notAllEqual}, we use the following method:

\begin{quote}
\begin{verbatim}
CtrArray forall(Rangesx4 rangesx4, Intx4Consumer c4) 
\end{verbatim}
\end{quote}

An object \nn{Rangesx4} represents the Cartesian product of four basic ranges. In our case, it is obtained by:
\begin{quote}
\begin{verbatim}
range(r).range(r).range(c).range(c)
\end{verbatim}
\end{quote}

So, when we write:
\begin{quote}
\begin{verbatim}
forall(range(r).range(r).range(c).range(c), (i1, i2, j1, j2) -> ...
\end{verbatim}
\end{quote}
it means: $\forall (i1,i2,j1,j2) \in 0..r-1 \times 0..r-1 \times 0..c-1 \times 0..c-1$, $\dots$

\bigskip
Finally, the objective function corresponds to the minimization of the maximum value taken by any variable in the two-dimensional array $x$.
Because domains are all similar, this is indeed equivalent to minimize the number of used colors.
Here are the methods that can be called to post an objective function (when no coefficients are required):

\begin{quote}
\begin{verbatim}
ObjEntity minimize(IVar x) 
ObjEntity minimize(TypeObjective type, IVar... list) 
ObjEntity minimize(TypeObjective type, IVar[][] list) 
ObjEntity minimize(TypeObjective type, IVar[][][] list) 

ObjEntity maximize(IVar x) 
ObjEntity maximize(TypeObjective type, IVar... list) 
ObjEntity maximize(TypeObjective type, IVar[][] list) 
ObjEntity maximize(TypeObjective type, IVar[][][] list) 
\end{verbatim}
\end{quote}

The sepcified type must take one of the following value\footnote{See Chapter 3 in \href{http://www.xcsp.org/format3.pdf}{\xt Specifications} for more information.}:
\begin{itemize}
\item EXPRESSION
\item SUM
\item PRODUCT
\item MINIMUM
\item MAXIMUM
\item NVALUES
\item LEX
\end{itemize}


\bigskip
To solve a specific instance, as usually, we have first to compile the model while indicating with the argument \verb!-data=! either the values for $r$ and $c$ or the name of a JSON file containing an object with two fields $r$ and $c$.
In the former case, this gives for $r=3$ and $c=3$: 
\begin{quote}
\begin{verbatim}
java modeler.Compiler BoardColoration -data=[3,3]
\end{verbatim}
\end{quote}

As you can observe, you need to use square brackets to surround values sepated by commas (no whitespace authorized).
The \xt file obtained after compilation is:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="COP">
  <variables>
    <array id="x" size="[3][3]"> 0..8 </array>
  </variables>
  <constraints>
    <group>
      <nValues>
        <list> %... </list>
        <condition> (gt,1) </condition>
      </nValues>
      <args> x[0][0] x[0][1] x[1][0] x[1][1] </args>
      <args> x[0][0] x[0][2] x[1][0] x[1][2] </args>
      <args> x[0][1] x[0][2] x[1][1] x[1][2] </args>
      <args> x[0][0] x[0][1] x[2][0] x[2][1] </args>
      <args> x[0][0] x[0][2] x[2][0] x[2][2] </args>
      <args> x[0][1] x[0][2] x[2][1] x[2][2] </args>
      <args> x[1][0] x[1][1] x[2][0] x[2]]1] </args>
      <args> x[1][0] x[1][2] x[2][0] x[2][2] </args>
      <args> x[1][1] x[1][2] x[2][1] x[2][2] </args>
    </group>
  </constraints>
  <objectives>
    <minimize type="maximum"> x[][] </minimize>
  </objectives>
</instance>
@\aft@
\end{lstlisting}

We can also build a file ``board-3-3.json'' whose content is:
\begin{quote}
\begin{verbatim}
{
  "r": 3,
  "c": 3
}
\end{verbatim}
\end{quote}
and execute:
\begin{quote}
\begin{verbatim}
java modeler.Compiler BoardColoration -data=board-3-3.json
\end{verbatim}
\end{quote}


\subsection{Magic Sequence}

A magic sequence of order $n$ is a sequence of integers $x_0,\dots,â¦x_{n-1}$ between 0 and $n-1$, such that each value $i \in 0..nâ1$ occurs exactly $x_i$ times in the sequence.
For example,
\begin{quote}
\begin{verbatim}
  6 2 1 0 0 0 1 0 0 0
\end{verbatim}
\end{quote}
is a magic sequence of order 10 since 0 occurs 6 times, 1 occurs twice, $\dots$ and 9 occurs 0 times.

One can prove that every solution respects:
\begin{quote}
  $x_0 + x_1 + x_2 + x_3 + \dots + x_{n-1} = 0$
\end{quote}
and
\begin{quote}
  $-1x_0 + 0x_1 + 1x_2 + 2x_3 + \dots + (n-2)x_{n-1} = 0$
\end{quote}

So, it may be a good idea to post these additional constraints  and making it clear that they are redundant (i.e., not modifying the set of solutions).
This gives:

\begin{lstlisting}
@\bef@
class MagicSequence implements ProblemAPI {
  int n;

  void model() {
    Var[] x = array("x", size(n), dom(range(n)));
    
    cardinality(x, range(n), x);
    
    block(() -> {
      sum(x, EQ, n);
      sum(x, range(-1, n - 2), EQ, 0);
    }).tag(REDUNDANT_CONSTRAINTS);
  }
}
@\aft@
\end{lstlisting}

On the one hand, the constraint \gb{cardinality} is exactly what we need here.
On the otehr hand, we have put together the two additional constraints in a so-called block, permitting to tag these two constraints (actually, the block) with the information ``redundantConstraints''.
The method that we have used is:

\begin{quote}
\begin{verbatim}
CtrArray block(Runnable r) 
\end{verbatim}
\end{quote}

and at this point, it is interesting to note that we can tag any constraint or group of constraints by calling \nn{tag()}.
If we execute:
\begin{quote}
\begin{verbatim}
java modeler.Compiler MagicSequence -data=6
\end{verbatim}
\end{quote}

we obtain the following \xt instance:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[6]"> 0..5 </array>
  </variables>
  <constraints>
    <cardinality>
      <list> x[] </list>
      <values> 0 1 2 3 4 5 </values>
      <occurs> x[] </occurs>
    </cardinality>
    <block class="redundantConstraints">
      <sum>
        <list> x[] </list>
        <condition> (eq,6) </condition>
      </sum>
      <sum>
        <list> x[] </list>
        <coeffs> -1 0 1 2 3 4 </coeffs>
        <condition> (eq,0) </condition>
      </sum>
    </block>
  </constraints>
</instance>
@\aft@
\end{lstlisting}

Note the presence of the attribute \nn{class} that results from the call to method \nn{tag()}.


\section{Structured Problems}

\subsection{Sudoku}

This well-known problem is stated as follows: fill in a grid using digits ranging from 1 to 9 such that:
\begin{itemize}
\item all digits occur on each row
\item all digits occur on each column
  \item all digits occur in each $3 \times 3$ block (starting at a position multiple of 1) 
\end{itemize}
An illustration is given by Figure \ref{fig:sudoku}.

\begin{figure}[h]
  \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[scale=1]{figures/sudoku1.pdf}
        \caption{Puzzle}
    \end{subfigure}%
    ~ 
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[scale=1]{figures/sudoku2.pdf}
        \caption{Solution}
    \end{subfigure}
    \caption{Solving a Sudoku Grid\label{fig:sudoku}}
\end{figure}

Because there are several clues, and because their number cannot be anticipated, we need a parameter $grid$ that represents a two-dimensional array of integer values.
When $grid[i][j]$ is 0, it means that the cell is empty, whereas when it contains a digit between 1 and 9, it means that it represents a fixed value (clue).
The model we can write is then:


\begin{lstlisting}
@\bef@
class Sudoku implements ProblemAPI {
  int[][] grid; // if not 0, grid[i][j] is a value imposed at row i and col j

  void model() {
    Var[][] x = array("x", size(9, 9), dom(range(1, 9)));

    allDifferentMatrix(x);
    forall(range(0, 8, 3).range(0, 8, 3), (i, j) -> {
      Var[] t = select(x, range(i, i + 2).range(j, j + 2));
      allDifferent(t);
    }).tag(BLOCKS);
    
    instantiation(x, grid, (i, j) -> grid[i][j] != 0).tag(CLUES);
  }
}
@\aft@
\end{lstlisting}

To ensure that all digits at different on each row and each column, we use:

\begin{quote}
\begin{verbatim}
CtrEntity allDifferentMatrix(Var[][] matrix) 
\end{verbatim}
\end{quote}

Then, we have to post a constraint \gb{allDifferent} on each block.
Note how we use the following method \nn{select()}:

\begin{quote}
\begin{verbatim}
<T extends IVar> T[] select(T[][] vars, Rangesx2 rangesx2) 
\end{verbatim}
\end{quote}

to extract the right subset of 9 variables for each block.

Finally, each clue (given value) represents a unary constraint.
We can post them using the constraint \gb{instantiation}.
The method that we use here is:

\begin{quote}
\begin{verbatim}
CtrEntity instantiation(Var[][] list, int[][] values, Intx2Predicate p) 
\end{verbatim}
\end{quote}
that permits to assign the variable $list[i][j]$ with the value $values[i][j]$ provided that $p$ returns true for $(i,j)$. 


Suppose now that we have a file 'grid.json'' containing:
\begin{quote}
\begin{verbatim}
{
  "grid": [
    [0,4,0,0,0,0,0,0,0],
    [5,3,9,0,0,1,0,6,0],
    [0,0,1,0,0,2,0,5,0],
    [4,0,7,2,0,9,0,0,6],
    [0,0,6,0,0,0,5,0,0],
    [8,0,0,6,0,3,1,0,7],
    [0,8,0,7,0,0,2,0,0],
    [0,6,0,3,0,0,4,1,8],
    [0,0,0,0,0,0,0,7,0]
  ]
}
\end{verbatim}
\end{quote}

then, we can execeute:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Sudoku -data=grid.json
\end{verbatim}
\end{quote}
and we obtain the following (simplified here) \xt instance:

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
    <array id="x" size="[9][9]"> 1..9 </array>
  </variables>
  <constraints>
    <allDifferent>
      <matrix> x[][] </matrix>
    </allDifferent>
    <group>
      <allDifferent> %... </allDifferent>
      <args> x[0..2][0..2] </args>
      <args> x[0..2][3..5] </args>
      <args> x[0..2][6..8] </args>
      <args> x[3..5][0..2] </args>
      <args> x[3..5][3..5] </args>
      <args> x[3..5][6..8] </args>
      <args> x[6..8][0..2] </args>
      <args> x[6..8][3..5] </args>
      <args> x[6..8][6..8] </args>
    </group>
    <instantiation class="clues" note="Just 2 clues here for the simplicity of the illustration">
      <list> x[0][1] x[8][7] </list>
      <values> 4 7 </values>
    </instantiation>
  </constraints>
</instance>
@\aft@
\end{lstlisting}


\subsection{Warehouse Location Problem}

In the Warehouse Location problem (WLP), a company considers opening warehouses at some candidate locations in order to supply its existing stores.
Each possible warehouse has the same maintenance cost, and a capacity designating the maximum number of stores that it can supply.
Each store must be supplied by exactly one open warehouse.
The supply cost to a store depends on the warehouse.
The objective is to determine which warehouses to open, and which of these warehouses should supply the various stores, such that the sum of the maintenance and supply costs is minimized.
See \href{http://csplib.org/Problems/prob034/}{CSPLib--Problem 034}.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.75]{figures/warehouse.jpg}
\end{center}
\caption{Warehouse.\label{fig:warehouse}}
\end{figure}

An example of data is the file ``warehouse.json'' containing:

{\small
  \begin{quote}
\begin{verbatim}
{
  "fixedCost": 30,
  "warehouseCapacities": [1,4,2,1,3],
  "storeSupplyCosts": [
    [100,24,11,25,30],[28,27,82,83,74],[74,97,71,96,70],[2,55,73,69,61],
    [46,96,59,83,4],[42,22,29,67,59],[1,5,73,59,56],[10,73,13,43,96],
    [93,35,63,85,46],[47,65,55,71,95]
  ]
}
\end{verbatim}
\end{quote}
}

A possible model is:

\begin{lstlisting}
@\bef@
class Warehouse implements ProblemAPI {
  int fixedCost;
  int[] warehouseCapacities;
  int[][] storeSupplyCosts;
  
  void model() {
    int nWarehouses = warehouseCapacities.length;
    int nStores = storeSupplyCosts.length;
    
    Var[] s = array("s", size(nStores), dom(range(nWarehouses)),
      "s[i] is the warehouse supplier of store i");
    Var[] c = array("c", size(nStores), i -> dom(storeSupplyCosts[i]),
      "c[i] is the cost of supplying store i");
    Var[] o = array("o", size(nWarehouses), dom(0, 1),
      "o[i] is 1 if the warehouse i is open");
    
    forall(range(nWarehouses),
      i -> atMost(s, i, warehouseCapacities[i]));
    forall(range(nStores),
      i -> element(o, s[i], 1));
    forall(range(nStores),
      i -> element(storeSupplyCosts[i], s[i], c[i]));

    int[] coeffs = vals(repeat(1,nStores),repeat(fixedCost,nWarehouses));
    minimize(SUM, vars(c,o), coeffs); 
  }
}
@\aft@
\end{lstlisting}

Here, it is intersting to see how we can define a specific domain to each variable of the array $c$ by means of a simple lambda function.
Remember that values are sorted and made distinct. 
The objective function corresponds to minimizing a weighted sum.
Note how \verb!vars(c,o)! builds a 1-dimensional array from two arrays, and how similarly the method \nn{vals()} concatenates integer values from two arrays to form a 1-dimensional array of integers.
On our example, the array $coeffs$ is \verb!1 1 1 1 1 1 1 1 1 1 30 30 30 30 30! because we have 10 stores and 5 warehouses.


After executing:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Warehouse -data=warehouse.json
\end{verbatim}
\end{quote}
and we obtain the following \xt instance (constraints are ommitted):

\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="COP">
  <variables>
    <array id="s" note="s[i] is the warehouse supplier of store i" size="[10]"> 0..4 </array>
    <array id="c" note="c[i] is the cost of supplying store i" size="[10]">
      <domain for="c[0]"> 11 24 25 30 100 </domain>
      <domain for="c[1]"> 27 28 74 82 83 </domain>
      <domain for="c[2]"> 70 71 74 96 97 </domain>
      <domain for="c[3]"> 2 55 61 69 73 </domain>
      <domain for="c[4]"> 4 46 59 83 96 </domain>
      <domain for="c[5]"> 22 29 42 59 67 </domain>
      <domain for="c[6]"> 1 5 56 59 73 </domain>
      <domain for="c[7]"> 10 13 43 73 96 </domain>
      <domain for="c[8]"> 35 46 63 85 93 </domain>
      <domain for="c[9]"> 47 55 65 71 95 </domain>
    </array>
    <array id="o" note="o[i] is 1 if the warehouse i is open" size="[5]"> 0 1 </array>
  </variables>
  <constraints>
    ...
  </constraints>
  <objectives>
    <minimize type="sum">
      <list> c[] o[] </list>
      <coeffs> 1 1 1 1 1 1 1 1 1 1 30 30 30 30 30 </coeffs>
    </minimize>
  </objectives>
</instance>
@\aft@
\end{lstlisting}


\subsection{Blackhole}

From WikiPedia. ``Black Hole is a solitaire card game. Invented by David Parlett, this game's objective is to compress the entire deck into one foundation.
The cards are dealt to a board in piles of three.
The leftover card, dealt first or last, is placed as a single foundation called the Black Hole.
This card usually is the Ace of Spades.
Only the top cards of each pile in the tableau are available for play and in order for a card to be placed in the Black Hole, it must be a rank higher or lower than the top card on the Black Hole. This is the only allowable move in the entire game.
The game ends if there are no more top cards that can be moved to the Black Hole. The game is won if all of the cards end up in the Black Hole.''
An illustration is given by Figure \ref{fig:solitaire}.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.4]{figures/solitaire.png}
\end{center}
\caption{Blackhole.\label{fig:solitaire}}
\end{figure}

We may want to play with various sizes of piles and various number of cards per suit.
An example of data is the file ``blackhole.json'' containing:

{\small
  \begin{quote}
\begin{verbatim}
{
  "nCardsPerSuit": 4,
  "nCardsPerPile": 3,
  "piles": [[1,4,13],[15,9,6],[14,2,12],[7,8,5],[11,10,3]]}
}
\end{verbatim}
\end{quote}
}

A possible model is:
 

\begin{lstlisting}
@\bef@
class Blackhole implements ProblemAPI {

  int nCardsPerSuit, nCardsPerPile;
  int[][] piles;

  void model() {
    int nCards = 4 * nCardsPerSuit;
    int nPiles = (nCards - 1) / nCardsPerPile;
    
    Var[] x = array("x", size(nCards), dom(range(nCards)),
      "x[i] is the value j of the card at the ith position of the built stack.");
    Var[] y = array("y", size(nCards), dom(range(nCards)),
      "y[j] is the position i of the card whose value is j");
    
    channel(x, y);
    equal(y[0], 0).note("The ace od Spades is the card initially on the stack");
    
    forall(range(nPiles).range(nCardsPerPile - 1),
      (i, j) -> lessThan(y[piles[i][j]], y[piles[i][j + 1]])
    ).note("Cards must be played in the order of the piles");
    
    int[][] tuples = range(nCards).range(nCards).select(
      (i, j) -> i % nCardsPerSuit == (j + 1) % nCardsPerSuit ||
                j % nCardsPerSuit == (i + 1) % nCardsPerSuit);
    slide(x, range(nCards - 1), i -> extension(vars(x[i], x[i + 1]), tuples));
  }
}
@\aft@
\end{lstlisting}  

Note how the constraint \gb{channel} is used to make a channelling between the two arrays $x$ and $y$,
and how tuples are built using an object \nn{Rangesx2} and a lambda function given as parameter of the method \nn{select()}.
Finally, we use the meta-constraint \gb{slide} to guarantee that each new card is at a rank higher or lower than the previous one.



After executing:
\begin{quote}
\begin{verbatim}
java modeler.Compiler Blackhole -data=blackhole.json
\end{verbatim}
\end{quote}
and we obtain the following \xt instance (some tuples have been ommitted; see the ellipsis $\dots$):


\begin{lstlisting}
@\bef@
<instance format="XCSP3" type="CSP">
  <variables>
  <array id="x" note="x[i] is the value j of the card at the ith pos. of the stack." size="[16]">
    0..15
  </array>
  <array id="y" note="y[j] is the position i of the card whose value is j" size="[16]">
    0..15
  </array>
  </variables>
  <constraints>
    <channel>
      <list> x[] </list>
      <list> y[] </list>
    </channel>
    <intension note="The ace od Spades is initially on the stack"> eq(y[0],0) </intension>
    <group note="Cards must be played in the order of the piles">
      <intension> lt(%0,%1) </intension>
      <args> y[1] y[4] </args>
      <args> y[4] y[13] </args>
      <args> y[15] y[9] </args>
      <args> y[9] y[6] </args>
      <args> y[14] y[2] </args>
      <args> y[2] y[12] </args>
      <args> y[7] y[8] </args>
      <args> y[8] y[5] </args>
      <args> y[11] y[10] </args>
      <args> y[10] y[3] </args>
    </group>
    <slide>
      <list collect="2"> x[] </list>
      <extension>
        <list> %0 %1 </list>
        <supports> (0,1)(0,3)(0,5)(0,7)(0,9)(0,11)...(15,14) </supports>
      </extension>
    </slide>
  </constraints>
</instance>
@\aft@
\end{lstlisting}  


\subsection{Rack Configuration Problem}


The rack configuration problem consists of plugging a set of electronic cards into racks with electronic connectors.
Each card plugged into a rack uses a connector.
In order to plug a card into a rack, the rack must be of a rack model.
Each card is characterised by the power it requires.
Each rack model is characterised by the maximal power it can supply, its number of connectors, and its price.
The problem is to decide how many of the available racks are actually needed such that: %, and which rack is of which rack model such that:
\begin{itemize}
\item every card is plugged into one rack
\item the total power demand and the number of connectors required by the cards does not exceed that available for a rack
\item the total price is minimised.
\end{itemize}
See \href{http://csplib.org/Problems/prob031/}{CSPLib--Problem 031}.

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.12]{figures/rack.jpg}
\end{center}
\caption{Rack.\label{fig:rack}}
\end{figure}

An example of data is the file ``rack.json'' containing:

{\small
\begin{quote}
\begin{verbatim}
{
  "nRacks": 10,
  "models": [[150,8,150],[200,16,200]],
  "cardTypes": [[20,20],[40,8],[50,4],[75,2]]
}
\end{verbatim}
\end{quote}
}

A possible model is:

\begin{lstlisting}
@\bef@
class Rack implements ProblemAPI {
  int nRacks;
  int[][] models; 
  int[][] cardTypes;

  void model() {
    models = addObject(models, tuple(0, 0, 0), 0); // we add first a dummy model (0,0,0)
    int nModels = models.length;
    int nTypes = cardTypes.length;
    int[] powers = columnOf(models, 0);
    int[] connectors = columnOf(models, 1);
    int[] prices = columnOf(models, 2);
    int[] cardPowers = columnOf(cardTypes, 0);
    int maxCapacity = IntStream.of(connectors).max().orElse(-1);
    
    Var[] r = array("r", size(nRacks), dom(range(nModels)),
      "r[i] is the model used for the ith rack");
    Var[][] c = array("c", size(nRacks, nTypes), (i, j) -> dom(range(0, Math.min(maxCapacity, cardTypes[j][1]))), "c[i][j] is the number of cards of type j put in the ith rack");
    Var[] rpw = array("rpw", size(nRacks), dom(powers),
      "rpw[i] is the power of the ith rack");
    Var[] rcn = array("rcn", size(nRacks), dom(connectors),
      "rcn[i] is the number of connectors of the ith rack");
    Var[] rpr = array("rpr", size(nRacks), dom(prices),
      "rpr[i] is the price of the ith rack");
    
    forall(range(nRacks), i -> extension(vars(r[i], rpw[i]), number(powers))).
      note("linking the ith rack with its power");
    forall(range(nRacks), i -> extension(vars(r[i], rcn[i]), number(connectors))).
      note("linking the ith rack with its number of connectors");
    forall(range(nRacks), i -> extension(vars(r[i], rpr[i]), number(prices))).
      note("linking the ith rack with its price");
    forall(range(nRacks), i -> sum(c[i], LE, rcn[i])).
      note("connector-capacity constraints");
    forall(range(nRacks), i -> sum(c[i], cardPowers, LE, rpw[i])).
      note("power-capacity constraints");
    forall(range(nTypes), i -> sum(columnOf(c, i), EQ, cardTypes[i][1])).
      note("demand constraints");
    decreasing(r).tag(SYMMETRY_BREAKING);
    
    minimize(SUM, rpr);
  }
}
@\aft@
\end{lstlisting}

Note how we use the method \nn{columnOf()} for getting the ith column of a two-dimensional array and the method \nn{number()} for converting a one-dimensional array into a two-dimensional array.
For example, if an array $t$ is defined by \verb!int[] t = {2,5,1}! then \verb!number(t)! returns an array $m$ just as if $m$ would have been defined by \verb!int[][] m = {{0,2},{1,5},{2,1}}!.

One drawback with the previous model is that it is difficult to understand the role of each piece of data, when we look at the JSON file isolated.
One possibility would be to propose a better structure as in this file ``rackb.json'':

{\small
\begin{quote}
\begin{verbatim}
{
  "nRacks": 10,
  "rackModels": [
    {"power":150,"nConnectors":8,"price":150},
    {"power":200,"nConnectors":16,"price":200}
  ],
  "cardTypes": [
    {"power":20,"demand":20},
    {"power":40,"demand":8},
    {"power":50,"demand":4},
    {"power":75,"demand":2}
  ]
}
\end{verbatim}
\end{quote}
}


Actually, in \xt, we can easily deal with such structured data, by developping a class for each type of objects.
This is what we do below with two inner classes, allowing us to represent rack models and card types.
The classes must be public, the fields must be public and we must have exactly one public constrctor.


\begin{lstlisting}
@\bef@
class Rack2 implements ProblemAPI {
  int nRacks;
  RackModel[] rackModels;
  CardType[] cardTypes;
  
  public class RackModel {
    public int power, nConnectors, price;
    
    public RackModel(int power, int nConnectors, int price) {
      this.power = power;
      this.nConnectors = nConnectors;
      this.price = price;
    }
  }
  
  public class CardType {
    public int power, demand;
    
    public CardType(int power, int demand) {
      this.power = power;
      this.demand = demand;
    }
  }
  
  void model() {
    rackModels = addObject(rackModels, new RackModel(0, 0, 0), 0); // we add a dummy model 
    int nModels = rackModels.length;
    int nTypes = cardTypes.length;
    int[] powers = Stream.of(rackModels).mapToInt(r -> r.power).toArray();
    int[] connectors = Stream.of(rackModels).mapToInt(r -> r.nConnectors).toArray();
    int[] prices = Stream.of(rackModels).mapToInt(r -> r.price).toArray();
    int[] cardPowers = Stream.of(cardTypes).mapToInt(r -> r.power).toArray();
    int maxCapacity = IntStream.of(connectors).max().orElse(-1);
    
    ... // the rest of the model remains the same
  }
}
@\aft@
\end{lstlisting}


\end{document}
